    .text
    .global main
    
main:
    # 设置根节点
    lui $8, 0x1000         # 将高16位加载到寄存器$8
    ori $9, $0, 0x000c     # 将低16位加载到寄存器$9
    lw $2, 0($8)           # 加载根节点左子树指针到寄存器$2
    lw $3, 0($9)           # 加载根节点右子树指针到寄存器$3
    lui $4, 0x0000         # 清零寄存器$4
    lui $5, 0x0000         # 清零寄存器$5
    
    # 前序遍历开始
preorder:
    slt $6, $2, $0         # 判断左子树指针是否为0
    beq $6, $0, preorder_r # 如果左子树指针为0，则跳转到右子树处理
    
    # 处理左子树
    addi $4, $4, 1         # 输出节点值
    lui $8, 0x1000         # 将高16位加载到寄存器$8
    add $8, $8, $2         # 加载左子树指针到寄存器$8
    lw $2, 0($8)           # 加载当前节点的左子树指针到寄存器$2
    lw $3, 4($8)           # 加载当前节点的右子树指针到寄存器$3
    j preorder             # 继续前序遍历
    
preorder_r:
    slt $6, $3, $0         # 判断右子树指针是否为0
    beq $6, $0, preorder_f # 如果右子树指针为0，则跳转到父节点处理
    
    # 处理右子树
    addi $5, $5, 1         # 输出节点值
    lui $8, 0x1000         # 将高16位加载到寄存器$8
    add $8, $8, $3         # 加载右子树指针到寄存器$8
    lw $2, 0($8)           # 加载当前节点的左子树指针到寄存器$2
    lw $3, 4($8)           # 加载当前节点的右子树指针到寄存器$3
    j preorder             # 继续前序遍历
    
preorder_f:
    slt $6, $4, $5         # 比较左子树和右子树的节点数量
    beq $6, $0, finish     # 如果左子树节点数量小于等于右子树节点数量，则跳转到结束
    
    # 输出节点值
    addi $4, $4, 1
    lui $8, 0x1000
    ori $9, $0, 0x0049
    add $8, $8, $9
    lw $9, 0($8)
    # 在此处执行输出操作
    
    lui $8, 0x1000         # 将高16位加载到寄存器$8
    ori $9, $0, 0x000c     # 将低16位加载到寄存器$9
    lw $2, 0($8)           # 加载根节点左子树指针到寄存器$2
    lw $3, 0($9)           # 加载根节点右子树指针到寄存器$3
    j preorder             # 继续前序遍历
    
finish:
    # 输出最后一个节点值
    lui $8, 0x1000
    ori $9, $0, 0x0049
    add $8, $8, $9
    lw $9, 0($8)
    # 在此处执行输出操作
    
    # 退出程序
    j $31
